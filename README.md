## Описание процесса сдачи лабораторных

### Получение доступа к репозиторию
- Зарегистрироваться на github.com (если аккаунта еще нет)
- Предоставить никнейм аккаунта в:
	- [Таблицу с результатами](https://docs.google.com/spreadsheets/d/1Y8oTRsiIrFpOYXScnwddTQjyQfsefWd68TfqODY-KE8)
- После этого дождаться подтверждения того, что вас добавили в команду репозитория
	- ваш никнейм в общей таблице выделен зеленым
- Принять приглашение к совместной работе над репозиторием (приходит на почту)
### Правила работы с репозиторием
- Вся работа ведется в вашей персональной ветке
	- Ветка должна именоваться `<group number>_<LastName>-<FirstName>`
	- Избегайте использования символов `/ , \ . | * +`
	- Не забывайте по завершении работы делать push в удаленную ветку
- По возможности старайтесь сделать красивую историю коммитов в ней
- **ЗАПРЕЩАЕТСЯ ОПРАВЛЯТЬ ИЗМЕНЕНИЯ В ВЕТКУ master**
	- Все ваши коммиты из ветки master будут удалены
	- Кара воспоследует
- Выполняете работу в **исходных файлах с заданиями**, если они присутствуют, там есть шаблон кода и описание, при этом **НЕ НУЖНО:**
	- Копировать эти файлы в ту же директорию
	- Создавать отдельную директорию для решиний
	- Переименовывать эти файлы
	- Перименовывать и менять сигнатуру методов шаблона кода внутри файла
### Отметки о сдаче задания
- Выполнив задание и отправив его код в свою ветку в репозиторий, отметьте соответствующий чекбокс в [Таблице с результатами](https://docs.google.com/spreadsheets/d/1Y8oTRsiIrFpOYXScnwddTQjyQfsefWd68TfqODY-KE8)
- После проверки преподавателем в этой таблице будет отмечено выполнение задание:
	- Зеленый - все хорошо
	- Желтый - принято, но можно лучше
	- Оранжевый - есть замечания, требующие исправления
	- Красный - задание не найдено, задание не выполнено, задание списано
	- Будет добавлен комментарий с замечаниями, после исправления замечаний стоит добавить свой комментарий в трек
### Задания

#### Java - 1

- Реализовать приложение - модуль, позволяющее генерировать случайные данные
- На вход:
  - набор переменных (имя, тип распределения)
  - Количество значений (общее для всех переменных)
  - формат выхода (CSV, database)
- На выход:
  - Путь к файлу с результатами
- Требования
  - типы распределений: равномерное, нормальное, пуассона
  - один модуль
  - Модульные тесты
  - "Хорошая" архитектура (декомпозиция, изоляция, SOLID)

#### Java - 2

- Использовать результаты из предыдущего задания
- Реализовать приложение, состоящее из модулей:
  - Модуль считывания данных
  - Модуль обработки данных
  - Модуль презентации результатов
- Считывание данных 
  - Считывание данных из CSV (отдельный модуль)
  - Считывание данных из СУБД (sqlite, hsqldb, h2, derby) (отдельный модуль)
- Обработка данных
  - проверка нормальности распределения по каждой переменной(отдельный модуль)
  - расчет среднего, медианы, минимального, максимального значений по каждой переменной (отдельный моудль)
- Презентация результатова 
  - вывод числовых результатов в JSON (среднее, медиана итд) (отдельный модуль)
  - вывод графика значений по каждой переменной в файл в виде изображения (отдельный модуль)
- формат данных
  - 8 колонок
  - не менее чем 65536 строк
  - в каждой ячейке double в формате (может быть задано экспонентой или с разделителем)
  - каждая строка - 8 значений переменных
  - заголовок - имена переменных
  - Значения минимум одной, максимум трёх, из переменных должны иметь нормальное распределение
- Требования
  - минимум 7 модулей (один описывает общую бизнес логику считывание-обработка-презентация данных и 6 модулей конкретных реализаций по работе с данными)
  - Модульные тесты
  - Логгирование
  - "Хорошая" архитектура (декомпозиция, изоляция, SOLID)

#### Java - 3
- Основано на задании ```Java - 2```
- Заменить модуль работы с базой данных на модуль работы с базой данных с использование Spring
- Реализовать модуль - REST API для:
  - Генерации данных с помощью алгоритма из ```Java - 1``` (на вход параметры, на выход id сформированного dataset в виде строки)
  - Получения результатов из задания ```Java - 2``` для данных из датасета (входной параметр)
    - получение JSON с числовыми значениями
	- Получение изображения
- Требования
  - Модульные тесты
  - Обработка ошибок
  - Логгирование
  - сборка в исполняемый JAR (порт является параметром запуска)
  - "Хорошая" архитектура (декомпозиция, изоляция, SOLID)
  
#### Scala  - 1
- В данном задании необходимо реализовать простые функции, используя рекурсию (допускается использование дополнительных "внутренних" функции)
- Функции
	- `def pascal(c: Int, r: Int): Int` - функция возвращающая значение элемента треугольника Паскаля по номеру колонки и строки
  
	![треугольник Паскаля](https://upload.wikimedia.org/wikipedia/commons/7/71/%D0%A2%D1%80%D0%B5%D1%83%D0%B3%D0%BE%D0%BB%D1%8C%D0%BD%D0%B8%D0%BA_%D0%9F%D0%B0%D1%81%D0%BA%D0%B0%D0%BB%D1%8F.png)
	- ` def balance(chars: List[Char]): Boolean` - функция, подсчитывающая баланс скобок в выражении (по открытым и закрытым скобкам)
	- `def countChange(money: Int, coins: List[Int])` - функция, определяющая количество возможных вариантов размена суммы (`money`) монетами номиналом (`coins`)
#### Scala  - 2
- В это задании необходимо реализовать множество целых числе заданное как функцию `type Set = Int => Boolean`, данная функция отвечает на вопрос "содержится ли заданный элемент в множестве", выделяя его таким образом из множества целых чисел
- Для выполнения задания необходимо представить свою реализацию функций, тело которых представлено как `???`
- После выполнения задания, подумайте над тем, где все-таки хранятся элементы множества
#### Scala  - 3
- Анаграмма слова - это перестановка его букв так, что образуется слово с другим значением. Например, если мы переставляем буквы слова `Elvis`, мы можем получить слово `lives`, которое является одной из его анаграмм.
- Анаграмма предложения - это перестановка всех символов в предложении так, что формируется новое предложение. Новое предложение состоит из значащих слов, количество которых может соответствовать или не соответствовать количеству слов в исходном предложении. Например, предложение: `I love you` - это анаграмма предложения `you olive` 
- При создании анаграмм мы будем игнорировать регистр символов и знаки препинания.
- Ваша конечная цель состоит в том, чтобы реализовать функцию, который, учитывая список слов, представляющих предложение, находит все анаграммы этого предложения. - Обратите внимание, что мы использовали термин «значимый» для определения анаграмм. Вам будет предоставлен словарь, то есть список слов, обозначающих слова, которые имеют значение.
- Общая идея:
	- Преобразовать символы предложения в список, содержащий пары - (символ, частота его появления в предложении)
	- Чтобы найти анаграммы слова, нужно найти слова из словаря, которые имеют одинаковый список вхождений. 
	- Чтобы найти анаграмму предложения необходимо извлечь из него любое подмножество символов, и попытаться сформировать какие-либо значимые слова. Из оставшихся символов мы решим задачу рекурсивно, а затем объединим все значимые слова, которые мы нашли, с рекурсивным решением.
#### Kotlin - `Grek`
- Урезанный grep - **grek**:
  - ```grek -n <regEx> <pathToSingleFile>```
  - ```grek -nr<regEx> <pathToFolder>```
  - ```grek -nr <regEx> <pathToFolder>```
  - ```grek -B 4 -A 5 -nr <regEx> <pathToFolder>```
- *Дополнительно:* использование параллелизма для ускорения работы
- Требования:
  - "Хорошая" архитектура (декомпозиция, изоляция, SOLID)
  - модульные тесты
  - сборка в испольняемые файлы под Linux и Windows